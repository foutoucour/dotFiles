import maya.cmds as cmds
import maya.mel as mel

from PyQt4 import QtCore
from PyQt4 import QtGui

from everyoneCan import multiLinkBlocker
from everyoneCan import SharedConstants
reload(SharedConstants)
scc                         = SharedConstants.Constants()
tl                          = SharedConstants.TypeLister()

#from everyoneCan import lightRigTypes

class Model:
    #==========================================================================
    # constants
    #==========================================================================
    __DEBUG = 0
    __LIST_SHADOW_CAMERA_ATTR = ['Switch',
                                 'Density',
                                 'Blur',
                                 'Samples',
                                 'Bias',
                                 'File']
    def __init__(self, oGui):
        self.__debug("__init__")
        self.__listLights       = []
        self.__listBlockers     = []
        self.__oGui             = oGui
        self.__oBlockerLinker   = multiLinkBlocker.Linker()
        self.__oBlockerMethods  = multiLinkBlocker.SharedMethods()
        
    def setListView(self, list):
        """
        @type list: list of QWidget
        """
        self.__debug("setListView")
        self.__listViews = list
        
    def setLightsViewName(self,string):
        self.__debug("setLightsViewName")
        self.__sLightsViewName = string
        
    def setBlockersViewName(self,string):
        self.__debug("setBlockersViewName")
        self.__sBlockersViewName = string
        
    def setSetsViewName(self,string):
        self.__debug("setSetsViewName")
        self.__sSetsViewName = string
    
    def setShadowCamerasViewName(self,string):
        self.__debug("setShadowCamerasViewName")
        self.__sShadowCamerasViewName = string
    
    def setShadowMapsViewName(self,string):
        self.__debug("setShadowMapsViewName")
        self.__sShadowMapsViewName = string
        
    def setPicturesViewName(self,string):
        if self.__DEBUG == 1:
            print "model, setPicturesViewName"
        self.__sShadowSetsViewName = string
        
    def setGeometriesViewName(self,string):
        self.__debug("setGeometriesViewName")
        self.__sGeometriesViewName = string
             
    def blockers(self):
        self.__debug("blockers")
        list = []
        for blocker in self.__listBlockers:
            try :
                cmds.getAttr('%s.alType' %blocker)
            except:
                self.__listBlockers.remove(blocker)
        if len(self.__listBlockers):
            for element in self.__listBlockers:
                sTag = cmds.getAttr('%s.alTag' %element)
                sTag = sTag.replace('al_','')
                sTag = sTag.upper()
                list.append([element, eval('scc.%s_ICON' %sTag)])
        return list

    def __findIcon(self, sValue):
        self.__debug("__findIcon")
        sTag = cmds.getAttr('%s.alTag' %sValue)
        sTag = sTag.replace('al_','')
        sTag = sTag.upper()
        return eval('scc.%s_ICON' %sTag)
                    
    def lights(self):
        self.__debug("lights")
        list = []
        for light in self.__listLights:
            try :
                cmds.getAttr('%s.alType' %light)
            except:
                self.__listLights.remove(light)
        for element in self.__listLights:
            list.append([element, self.__findIcon(element)])
        for key, items in self.__dictCameras.items():
            if key == tl.LIGHT :
                for item in items:
                    list.append([item, self.__findIcon(item)])
        return list

    def shadowCameras(self):
        self.__debug("shadowCameras")
        self.__listShadowCameras    = []
        list                        = []
        for key, items in self.__dictCameras.items():
            if key == tl.SHADOW_CAMERA :
                for item in items:
                    list.append([item, scc.SHADOW_CAMERA_ICON])
                    self.__listShadowCameras.append(item)
         
        return list
    
    def shadowMaps(self):
        self.__debug("shadowMaps")
        self.__listShadowMaps = self.__fakeFill(8)
        return self.__listShadowMaps
    
    def pictures(self):
        self.__debug("pictures")
        self.__listPictures = []
        list = []
        for sFile in cmds.ls(et='script'):
            try :
                cmds.getAttr('%s.alPicture' %sFile)
                list.append([sFile, scc.FILE_ICON])
                self.__listPictures.append(sFile)
            except :
                pass
        return list
    
    def sets(self):
        self.__debug("sets")
        list                = []
        self.__listSets     = []
        for sSet in cmds.ls(sets=1):
            if cmds.listRelatives(sSet, p=1) == None:
                if cmds.nodeType(sSet) == 'objectSet':
                    sIconPath = self.setSetsIcon(sSet)
                    list.append([sSet, sIconPath])
                    self.__listSets.append(sSet)
        return list
    
    def setSetsIcon(self, sSet):
        sLight      = 0
        sShadow     = 0 
        self.__debug("setSetsIcon")
        sIconPath = scc.EMPTY_SET_ICON
        if cmds.listConnections(sSet):
            for sConn in cmds.listConnections(sSet, c=1):
                try : 
                    sType = cmds.getAttr('%s.alType' %sConn)
                    if sType == tl.LIGHT:
                        sLight = 1
                    if sType == tl.SHADOW_CAMERA:
                        sShadow = 1
                except :
                    pass
        sIconPath = 'scc.'
        if sLight == 1:
            sIconPath += 'LIGHT'
        if sShadow == 1:
            sIconPath += 'SHADOW'
        if sIconPath == 'scc.':
            sIconPath += 'EMPTY'
        sIconPath += '_SET_ICON'
        sIconPath = eval(sIconPath)
        return sIconPath
    
    def geometries(self):
        self.__debug("geometries")
        self.__listGeometries       = []
        list                        = []
        for sShape in cmds.ls(g=1):
            try :
                cmds.getAttr('%s.alTag' %sShape)
            except :
                sGeometry = cmds.listRelatives(sShape, p=1)[0]
                self.__listGeometries.append(sGeometry)
                list.append([sGeometry, ''])
        return list

    def __fakeFill(self, i):
        self.__debug("__fakeFill")
        # tmp fonction
        list = []
        a = 0
        while a < i:
            list.append([str(a), ''])
            a += 1
        return list

    def getAssemblies(self):
        self.__debug("getAssemblies")
        self.__listLights   = []
        self.__listBlockers  = []
        for sSel in cmds.ls(assemblies=1):
            sShape = cmds.listRelatives(sSel)[0]
            sType = cmds.nodeType(sShape)
            if tl.LIGHT in sType:
                self.__listLights.append(sSel)
            elif sType == 'liquidCoordSys':
                self.__listBlockers.append(sSel)
        
    def getCameras(self):
        self.__debug("getCameras")
        """ 
        self.__dictCameras stores all alTyped cameras
        that can be magicLights (typed light) listed as light
        or shadowCameras (typed shadowCameras) listed as shadowCamera.
        """
        self.__dictCameras                     = {}
        for sShape in cmds.ls(cameras=1):
            # we need to check the transform group
            # as every shapes are typed shape
            sCamera = cmds.listRelatives(sShape, p=1)[0]
            try :
                sType = cmds.getAttr('%s.alType' %sCamera)
                # we create a key.
                # the value of the key is the type of camera
                # that allows to group all cameras by their type
                # without knowing types of cameras
                if not sType in self.__dictCameras.keys():
                    self.__dictCameras[sType] = []
                self.__dictCameras[sType].append(sCamera)
            except :
                # we are not interested in regular cameras
                pass
    
    def select(self, listSel):
        self.__debug("fromSelection")
        """
        Clear the selection and select object in listSel.
        
        @type listSel: list of strings
        @param listSel: names of objects to select
        """
        # selection of object(s) in Maya
        cmds.select(clear=1)
        if len(listSel)>0:
            cmds.select(listSel)
    
    def findConnections(self, listSel, sType):
        self.__debug("findConnections")
        """ 
        find connections of selection
        """
        listConnections = []
        for sSel in listSel :
            if cmds.listConnections(sSel):
                for sConn in cmds.listConnections(sSel):
                    if not sConn == sSel:
                        # is in blocker list ?
                        if sConn in self.__listBlockers and \
                                not sType == self.__sBlockersViewName:
                            if not sConn in listConnections:
                                listConnections.append([self.__sBlockersViewName, 
                                                        sConn])
                        # is in light list ?
                        if sConn in self.__listLights and  \
                                not sType == self.__sLightsViewName:
                            if not sConn in listConnections:
                                listConnections.append([self.__sLightsViewName, 
                                                        sConn])
                        # is in shadowCamera list ?
                        if sConn in self.__listShadowCameras and \
                                not sType == self.__sShadowCamerasViewName:
                            if not sConn in listConnections:
                                listConnections.append([self.__sShadowCamerasViewName, 
                                                        sConn])
                        # is in shadowMap list ?
#                        if sConn in self.__listShadowMaps and \
#                                not sType == self.__sShadowMapsViewName:
#                            if not sConn in listConnections:
#                                listConnections.append([self.__sShadowMapsViewName, 
#                                                        sConn])
                        # is in picture list ?
                        if sConn in self.__listPictures:
                            if not sConn in listConnections:
                                listConnections.append([self.__sShadowSetsViewName, 
                                                        sConn])
                        # is in set list ?
                        if sConn in self.__listSets and \
                                not sType == self.__sSetsViewName:
                            if not sConn in listConnections:
                                listConnections.append([self.__sSetsViewName, 
                                                 sConn])
                        # is in geometry list ?
                        if sConn in self.__listGeometries and \
                                not sType == self.__sGeometriesViewName:
                            if not sConn in listConnections:
                                listConnections.append([self.__sGeometriesViewName, 
                                                        sConn])
        return listConnections 

    def __getSets(self):
        self.__debug("__getSets")
        listSets    = []
        for sSet in cmds.ls(sets=1):
            if cmds.listRelatives(sSet, p=1) == None:
                if cmds.nodeType(sSet) == 'objectSet':
                    try :
                        linkedLights = cmds.getAttr('%s.liqLinkedLights' %sSet)
                        if len(linkedLights[0]) == 0:
                            sIconPath = scc.EMPTY_SET_ICON
                        else :
                            sIconPath = scc.LIGHT_SET_ICON
                    except :
                        sIconPath = scc.EMPTY_SET_ICON
                    listSets.append([sSet, sIconPath])
                    
        return listSets
    
    def createSet(self):
        self.__debug("createSet")
        text, ok = QtGui.QInputDialog.getText(None,
                                              'Namer', 
                                              'Enter a name:',
                                              QtGui.QLineEdit.Normal,
                                              'set')
        if ok:
            cmds.sets(name=str(text), em=1)
    
#    def __setName(self, sName):
#        """
#        Call of an instance of ec__Namer.Naming Class.
#        It allows to set a name to the reference.
#        @type sNamespace: string
#        @param sNamespace: current name of the reference
#        """
#        text, ok = QtGui.QInputDialog.getText(None,
#                                              'Namer', 
#                                              'Enter a name:',
#                                              QtGui.QLineEdit.Normal,
#                                              sName)
#        if ok:
#            self.__getValueAndRename(str(text))
            
    def getType(self, string):
        self.__debug("getType")
        return self.__oBlockerMethods.getType(string)
    
    def actionGeo2Set(self, listSelection, oItem, boolMode):
        self.__debug("actionGeo2Set")
        sSet = str(oItem.text())
        for element in listSelection:
            sSel = str(element.text())
            if boolMode ==  1:
                if cmds.sets(sSel,im=sSet) == 0:
                    self.__addGeo2Set(sSel, sSet)
            else :
                if cmds.sets(sSel,im=sSet):
                    self.__removeGeo2Set(sSel, sSet)
    
    def actionSet2Geo(self, listSelection, oItem, boolMode):
        self.__debug("actionSet2Geo")
        sGeo = str(oItem.text())
        for element in listSelection:
            sSel = str(element.text())
            if boolMode ==  1:
                if cmds.sets(sGeo,im=sSel) == 0:
                    self.__addGeo2Set(sGeo, sSel)
            else :
                if cmds.sets(sGeo,im=sSel):
                    self.__removeGeo2Set(sGeo, sSel)
  
    def __addGeo2Set(self, sGeo, sSet):
        self.__debug("__addGeo2Set")
        cmds.sets(sGeo,add=sSet)
    
    def __removeGeo2Set(selfsGeo, sSet):
        self.__debug("__removeGeo2Set")
        cmds.sets(sGeo,rm=sSet)
        
    def actionSet2Light(self, listSelection, oItem, boolMode):
        self.__debug("actionSet2Light")
        sLight = str(oItem.text())
        sShape = cmds.listRelatives(sLight)[0]
        for element in listSelection:
            sSel = str(element.text())
            if boolMode ==  1:
                try :
                    self.__linkLight2Set(sShape, sSel)
                except :
                    pass
            else :
                try :
                    self.__unlinkLight2Set(sShape, sSel)
                except:
                    pass
    
    
    def actionLight2Set(self, listSelection, oItem, boolMode):
        self.__debug("actionLight2Set")
        sSel = str(oItem.text())
        for element in listSelection:
            sLight = str(element.text())
            sShape = cmds.listRelatives(sLight)[0]
            if boolMode ==  1:
                try :
                    self.__linkLight2Set(sShape, sSel)
                except :
                    pass
            else :
                try :
                    self.__unlinkLight2Set(sShape, sSel)
                except:
                    pass
                
    def __linkLight2Set(self, sLightShape, sSet):
        self.__debug("__linkLight2Set")
        mel.eval('LLL_link %s %s' %(sLightShape, sSet))
    
    def __unlinkLight2Set(self, sLightShape, sSet):
        self.__debug("__unlinkLight2Set")
        mel.eval('LLL_unlink %s %s' %(sLightShape, sSet))
    
    def actionLight2Blocker(self, listSelection, oItem, boolMode):
        self.__debug("actionLight2Blocker")
        sSel = str(oItem.text())
        for element in listSelection:
            sLight = str(element.text())
            if boolMode ==  1:
                try :
                    self.__block(sLight, sSel)
                except :
                    pass
            else :
                try :
                    self.__unblock(sLight, sSel)
                except:
                    pass
    
    def actionBlocker2Light(self, listSelection, oItem, boolMode):
        self.__debug("actionBlocker2Light")
        sSel = str(oItem.text())
        for element in listSelection:
            sBlocker = str(element.text())
            if boolMode ==  1:
                try :
                    self.__block(sSel, sBlocker)
                except :
                    pass
            else :
                try :
                    self.__unblock(sSel, sBlocker)
                except:
                    pass
            
    def actionShadowCam2Set(self, listSelection, oItem):
        self.__debug("actionShadowCam2Set")
        sSel = str(oItem.text())
        for element in listSelection:
            sShadowCam = str(element.text())
            self.__shadowSetLink(sSel, sShadowCam)
    
    def actionSet2ShadowCam(self, listSelection, oItem):
        self.__debug("actionShadowCam2Set")
        sSel = str(oItem.text())
        for element in listSelection:
            sSet = str(element.text())
            self.__shadowSetLink(sSet, sSel)
            
    def __shadowSetLink(self, sSet, sShadowCamera):
        self.__debug("__shadowSetLink")
        sShadowCamShape = cmds.listRelatives(sShadowCamera)[0]
        cmds.setAttr('%s.liqGeometrySet' %sShadowCamShape, 
                     sSet,
                     type="string")
        if 'alShadowSet' in cmds.listAttr(sShadowCamShape):
            cmds.deleteAttr('%s.alShadowSet' %sShadowCamShape)
        cmds.addAttr(sShadowCamShape, 
                            sn='alShadowSet', 
                            dataType='string', 
                            h=1)
        cmds.connectAttr('%s.message' %sSet,
                         '%s.alShadowSet' %sShadowCamShape)
    
    
    def actionShadowCam2Light(self, listSelection, oItem, boolMode):
        self.__debug("actionShadowCam2Light")
        sSel = str(oItem.text())
        sShader = ''
        for i in cmds.listConnections(sSel):
            try:
                if cmds.getAttr('%s.alType' %i) == tl.LIQUID_LIGHT_SHADER:
                    sShader = i
                    break
            except :
                pass
            
        if not sShader == '':
            for element in listSelection:
                sShadowCam = str(element.text())
                sShadowCamShape = cmds.listRelatives(sShadowCam)[0]
                if boolMode == 1:
                    if not sShadowCamShape in cmds.listConnections(sShader):
                        self.__connectShadowCam2Shader(sShadowCam, sShader)
                else :
                    if sShadowCam in cmds.listConnections(sShader):
                        self.__disconnectShadowCam2Shader(sShadowCam, sShader)
    
    def actionLight2ShadowCamera(self, listSelection, oItem, boolMode):
        self.__debug("actionLight2ShadowCamera")
        sSel = str(oItem.text())
        print sSel


    def __connectShadowCam2Shader(self, sShadowCam, sShader):
        self.__debug("__connectShadowCam2Shader")
        a = 0
        sShadowCamShape = cmds.listRelatives(sShadowCam)[0]
        while a>-1:
            sConn = '%s.shadowCameras[%d]' %(sShader, a)
            if not sConn in cmds.listConnections(sShader, c=1):
                try:
                    for attr in self.__LIST_SHADOW_CAMERA_ATTR:
                        print attr
                        if attr == 'File':
                            cmds.setAttr('%s.Shadow_%s[%d]' %(sShader, attr, a),
                                    'autoshadow[%d]' %a,
                                    type='string')
                        else :
                            cmds.connectAttr('%s.%s' %(sShadowCam, attr),
                                     '%s.Shadow_%s[%d]' %(sShader, attr, a))
                    print 'eval'
                    mel.eval('connectExistingShadowCamera %s  -source %s;'\
                             %(sConn,sShadowCamShape))
                except:
                    pass
                break
            a+=1
    
    def __disconnectShadowCam2Shader(self, sShadowCam, sShader):
        self.__debug("__disconnectShadowCam2Shader")
        a = 0
        sShadowCamShape = cmds.listRelatives(sShadowCam)[0]
        while a<50:
            sConn = '%s.shadowCameras[%d]' %(sShader, a)
            if sShadowCam in cmds.listConnections(sConn, c=1):
                cmds.disconnectAttr('%s.message' %sShadowCamShape,
                                    sConn)
                for attr in self.__LIST_SHADOW_CAMERA_ATTR:
                    if attr == 'File':
                        cmds.setAttr('%s.Shadow_%s[%d]' %(sShader, attr, a),
                                    '',
                                    type='string')
                    else :
                        cmds.disconnectAttr('%s.%s' %(sShadowCam, 
                                                      attr),
                                            '%s.Shadow_%s[%d]' %(sShader, 
                                                                 attr, 
                                                                 a))
                break
            a+=1
                    
    def __block(self, sLight, sBlocker):
        self.__debug("__block")
        self.__oBlockerLinker.setBlocker(sBlocker)
        self.__oBlockerLinker.setLight(sLight)
        self.__oBlockerLinker.add()

    def __unblock(self, sLight, sBlocker):
        self.__debug("__unblock")
        self.__oBlockerLinker.setBlocker(sBlocker)
        self.__oBlockerLinker.setLight(sLight)
        self.__oBlockerLinker.remove()
    
    
    def actionPicture2Light(self, listSelection, oItem, boolMode):
        self.__debug("actionPicture2Light")
        print listSelection, oItem.text(), boolMode
    
    
    def __debug(self, string):
        if self.__DEBUG == 1:
            print "Model.%s()" %string
# Ni !